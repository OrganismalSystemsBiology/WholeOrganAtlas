
//param_merge.json
Dir_check(dir + "\\param");
filename = dir + "\\param\\param_merge.json";
StreamWriter^ sw2 = gcnew StreamWriter(filename);

double zoverlap = double::Parse(Z_overlap_box->Text);
double zstep = double::Parse(Step->Text);

String^ zoverlap_s = ((int)(zoverlap / zstep)).ToString("D8");
sw2->WriteLine("\"#\": \"3\",");
sw2->WriteLine("\"HDoG_paramfile\": {");
sw2->WriteLine("\"FW\": \"/home/yoshida/CUBIC-informatics/param/OrganAtlas/*******/param_FW.json, ");
sw2->WriteLine("\"RV\": \"/home/yoshida/CUBIC-informatics/param/OrganAtlas/*******/param_RV.json");
sw2->WriteLine("},");
sw2->WriteLine("\"dst_basedir\": \"/export3/Imaging/yoshida/**********/scalemerged/\",");
sw2->WriteLine("\"merge_info\": {");
sw2->WriteLine("\"#\": \"specify the filename at the boundary\",");
sw2->WriteLine("\"#\": \"as either string without extension or integer\",");
sw2->WriteLine("\"boundary_fname\": {");
sw2->WriteLine("\"FW\": \"" + zoverlap_s + "\",");
sw2->WriteLine("\"RV\":  \"" + zoverlap_s + "\",");
sw2->WriteLine("},");
sw2->WriteLine("\"use_at_boundary\": \"RV\",");
sw2->WriteLine("\"flip_rot\": {");
sw2->WriteLine("\"FW\": {");
sw2->WriteLine("\"flipX\": false,");
sw2->WriteLine("\"flipY\": false,");
sw2->WriteLine("\"rotCW\": false,");
sw2->WriteLine("\"rotCCW\": true");
sw2->WriteLine("},");
sw2->WriteLine("\"RV\": {");
sw2->WriteLine("\"flipX\": true,");
sw2->WriteLine("\"flipY\": false,");
sw2->WriteLine("\"rotCW\": false,");
sw2->WriteLine("\"rotCCW\": true");
sw2->WriteLine("}");	sw2->WriteLine("}");	sw2->WriteLine("},");
sw2->WriteLine("\"scale_info\": {");
sw2->WriteLine("\"#\": \"the length of three side of downscaled voxel(um)\",");
sw2->WriteLine("\"#\": \"should be divisible by scale_z\",");
sw2->WriteLine("\"downscale_unit\": 80,");
sw2->WriteLine("\"flip_rot\": {");
sw2->WriteLine("\"flipX\": false,");
sw2->WriteLine("\"flipY\": false,");
sw2->WriteLine("\"flipZ\": false,");
sw2->WriteLine("}");		sw2->WriteLine("}");		sw2->WriteLine("");	sw2->WriteLine("}");
sw2->Close();
cout << "param_RV.json" << endl;
//param_RV.json
filename = dir + "\\param\\param_RV.json";
StreamWriter^ sw3 = gcnew StreamWriter(filename);
sw3->WriteLine("\"#\": \"2\",");
sw3->WriteLine("\"dst_basedir\": \"/export3/Imaging/yoshida/*********/candidate/RV/\",");
sw3->WriteLine("\"src_basedir\": \"/home/yoshida/GPSi/Matsumoto/OrganAtlas/*********/RV/");
sw3->WriteLine("\"gpus\": [0,1,2,3],");
sw3->WriteLine("\"dst_basedir\": \"/export3/Imaging/yoshida/OrganAtlas/SalivaryGlands/200102/scalemerged/\",");
sw3->WriteLine("\"input_image_info\": {");
sw3->WriteLine("\"width\": 2048,");
sw3->WriteLine("\"height\": 2048,");
sw3->WriteLine("\"left_margin\": " + Ystep_px + ",");
sw3->WriteLine("\"right_margin\": " + Ystep_px + ",");
sw3->WriteLine("\"top_margin\": " + Xstep_px + ",");
sw3->WriteLine("\"bottom_margin\": " + Xstep_px + ",");
sw3->WriteLine("},");
sw3->WriteLine("\"coordinate_info\": {");
sw3->WriteLine("\"#\": \"local coordinate(pixel to um)\",");
sw3->WriteLine("\"#\": \"global coordinate(um) = local coordinate(pixel) * scale + offset\",");
sw3->WriteLine("\"scale_x\": " + (PIXELSIZE*mag).ToString() + ",");
sw3->WriteLine("\"scale_y\": -" + (PIXELSIZE*mag).ToString() + ",");
sw3->WriteLine("\"scale_z\": " + zstep.ToString() + ",");
sw3->WriteLine("\"#\": \"global coordinate(filename to um)\",");
sw3->WriteLine("\"#\": \"origin of local coordinate = Affine_trasform(filename)\",");
sw3->WriteLine("\"affine_global\": [");
sw3->WriteLine("\t[0.0,-0.1,0.0, 0],");
sw3->WriteLine("\t[-0.1,0.0,0.0, 0],");
sw3->WriteLine("\t[0.0,0.0,0.0, -" + zoverlap.ToString() + "]");
sw3->WriteLine("]");
sw3->WriteLine("},");
sw3->WriteLine("\"HDoG_param\": {");
sw3->WriteLine("\"#\": \"the number of images to be processed at once\",");
sw3->WriteLine("\"depth\": 32,");
sw3->WriteLine("\"#\": \"the number of discarded images because of poor quality\",");
sw3->WriteLine("\"extra_depth_margin\": 3,");
sw3->WriteLine("\"#\": \"parameter to adjust size of temporary memory\",");
sw3->WriteLine("\"#\": \"increase if the program says so\",");
sw3->WriteLine("\"cub_tmp_size_factor\": 8.001,");
sw3->WriteLine("\"#\": \"Every image should have at least following maximum intensity\",");
sw3->WriteLine("\"min_intensity_skip\": 500,");
sw3->WriteLine("\"#\": \"In intensity normalization, background intensity is \",");
sw3->WriteLine("\"#\": \"calculated from neighborhood area with this size\",");
sw3->WriteLine("\"radius_norm\": {");
sw3->WriteLine("\"xy_small\": 24,");
sw3->WriteLine("\"z_small\": 3,");
sw3->WriteLine("\"xy_large\": 100,");
sw3->WriteLine("\"z_large\": 5,");
sw3->WriteLine("},");
sw3->WriteLine("\"#\": \"Normalized intensity is zero when original intensity is\",");
sw3->WriteLine("\"#\": \"larger than background intensity plus the below value\",");
sw3->WriteLine("\"min_intensity\": 500,");
sw3->WriteLine("");
sw3->WriteLine("\"#\": \"Parameters for scale selection by DoG\",");
sw3->WriteLine("\"gamma_n\": 1.0,");
sw3->WriteLine("\"sigma_dog\": {");
sw3->WriteLine("\"xy_small\": 4.0,");
sw3->WriteLine("\"z_small\": 1.8,");
sw3->WriteLine("\"xy_large\": 6.0,");
sw3->WriteLine("\"z_large\": 2.7,");
sw3->WriteLine("},");
sw3->WriteLine("\"#\": \"Parameters to remove obviously noisy regions from output\",");
sw3->WriteLine("\"min_size\": 10,");
sw3->WriteLine("},");
sw3->WriteLine("\"#\": \"Parameters for each GPU\",");
sw3->WriteLine("\"#\": \"the followings are automatically overwritten by a python script\",");
sw3->WriteLine("}");
sw3->Close();
cout << "param_FV.json" << endl;
//param_FW.json
filename = dir + "\\param\\param_FW.json";
sw3 = gcnew StreamWriter(filename);
sw3->WriteLine("\"#\": \"2\",");
sw3->WriteLine("\"dst_basedir\": \"/export3/Imaging/yoshida/*********/candidate/FW/\",");
sw3->WriteLine("\"src_basedir\": \"/home/yoshida/GPSi/Matsumoto/OrganAtlas/*********/FW/");
sw3->WriteLine("\"gpus\": [0,1,2,3],");
sw3->WriteLine("\"input_image_info\": {");
sw3->WriteLine("\"width\": 2048,");
sw3->WriteLine("\"height\": 2048,");
sw3->WriteLine("\"left_margin\": " + Ystep_px + ",");
sw3->WriteLine("\"right_margin\": " + Ystep_px + ",");
sw3->WriteLine("\"top_margin\": " + Xstep_px + ",");
sw3->WriteLine("\"bottom_margin\": " + Xstep_px + ",");
sw3->WriteLine("},");
sw3->WriteLine("\"coordinate_info\": {");
sw3->WriteLine("\"#\": \"local coordinate(pixel to um)\",");
sw3->WriteLine("\"#\": \"global coordinate(um) = local coordinate(pixel) * scale + offset\",");
sw3->WriteLine("\"scale_x\": " + (PIXELSIZE*mag).ToString() + ",");
sw3->WriteLine("\"scale_y\": " + (PIXELSIZE*mag).ToString() + ",");
sw3->WriteLine("\"scale_z\": -" + zstep.ToString() + ",");
sw3->WriteLine("\"#\": \"global coordinate(filename to um)\",");
sw3->WriteLine("\"#\": \"origin of local coordinate = Affine_trasform(filename)\",");
sw3->WriteLine("\"affine_global\": [");
sw3->WriteLine("\t[0.0,-0.1,0.0, 0],");
sw3->WriteLine("\t[-0.1,0.0,0.0, 0],");
sw3->WriteLine("\t[0.0,0.0,0.0, " + zoverlap.ToString() + "]");
sw3->WriteLine("]");
sw3->WriteLine("},");
sw3->WriteLine("\"HDoG_param\": {");
sw3->WriteLine("\"#\": \"the number of images to be processed at once\",");
sw3->WriteLine("\"depth\": 32,");
sw3->WriteLine("\"#\": \"the number of discarded images because of poor quality\",");
sw3->WriteLine("\"extra_depth_margin\": 3,");
sw3->WriteLine("\"#\": \"parameter to adjust size of temporary memory\",");
sw3->WriteLine("\"#\": \"increase if the program says so\",");
sw3->WriteLine("\"cub_tmp_size_factor\": 8.001,");
sw3->WriteLine("\"#\": \"Every image should have at least following maximum intensity\",");
sw3->WriteLine("\"min_intensity_skip\": 500,");
sw3->WriteLine("\"#\": \"In intensity normalization, background intensity is \",");
sw3->WriteLine("\"#\": \"calculated from neighborhood area with this size\",");
sw3->WriteLine("\"radius_norm\": {");
sw3->WriteLine("\"xy_small\": 24,");
sw3->WriteLine("\"z_small\": 3,");
sw3->WriteLine("\"xy_large\": 100,");
sw3->WriteLine("\"z_large\": 5,");
sw3->WriteLine("},");
sw3->WriteLine("\"#\": \"Normalized intensity is zero when original intensity is\",");
sw3->WriteLine("\"#\": \"larger than background intensity plus the below value\",");
sw3->WriteLine("\"min_intensity\": 500,");
sw3->WriteLine("");
sw3->WriteLine("\"#\": \"Parameters for scale selection by DoG\",");
sw3->WriteLine("\"gamma_n\": 1.0,");
sw3->WriteLine("\"sigma_dog\": {");
sw3->WriteLine("\"xy_small\": 4.0,");
sw3->WriteLine("\"z_small\": 1.8,");
sw3->WriteLine("\"xy_large\": 6.0,");
sw3->WriteLine("\"z_large\": 2.7,");
sw3->WriteLine("},");
sw3->WriteLine("\"#\": \"Parameters to remove obviously noisy regions from output\",");
sw3->WriteLine("\"min_size\": 10,");
sw3->WriteLine("},");
sw3->WriteLine("\"#\": \"Parameters for each GPU\", ");
sw3->WriteLine("\"#\": \"Parameters for each GPU\", ");
sw3->WriteLine("\"#\": \"the followings are automatically overwritten by a python script\",");
sw3->WriteLine("}");
sw3->Close();

cout << "param_classify.json" << endl;
filename = dir + "\\param\\param_classify.json";
sw3 = gcnew StreamWriter(filename);
sw3->WriteLine("\"#\": \"2\",");
sw3->WriteLine("\"MergeBrain_paramfile\": \"/home/yoshida/CUBIC-informatics/param/*********/param_merge.json\",");
sw3->WriteLine("");
sw3->WriteLine("\"dst_basedir\": \"/export3/Imaging/yoshida/*********/classify/");
sw3->WriteLine("");
sw3->WriteLine("\"classifier_name\": \"clf_dt\",");
sw3->WriteLine("\"density_img_name\": \"img_density\",");
sw3->WriteLine("");
sw3->WriteLine("\"#\": \"use manual boundary or automatic boundary\",");
sw3->WriteLine("\"use_manual_boundary\": true,");
sw3->WriteLine("");
sw3->WriteLine("\"#\": \"Use only 1/num_skip samples to train and plot\",");
sw3->WriteLine("\"num_skip_samples\": 100000,");
sw3->WriteLine("");
sw3->WriteLine("\"manual_boundary\": {");
sw3->WriteLine("\"#\": \"set the boundary line coefficient\",");
sw3->WriteLine("\"#\": \"a * x_1 + b * x_2 + c > 0 is regarded as positive\",");
sw3->WriteLine("\"#\": \"  where x_1 is logarithm of intensity\",");
sw3->WriteLine("\"#\": \"  and x_2 is logarithm of structureness\",");
sw3->WriteLine("\"a\": 1.7,");
sw3->WriteLine("\"b\": 0,");
sw3->WriteLine("\"c\": 1");
sw3->WriteLine("},");
sw3->WriteLine("");
sw3->WriteLine("\"automatic_boundary\": {");
sw3->WriteLine("\"#\": \"The number of clusters in unsupervised classification\",");
sw3->WriteLine("\"num_clusters\": 2,");
sw3->WriteLine("");
sw3->WriteLine("\"#\": \"The true cell cluster is the one with largest mean value of this feature\",");
sw3->WriteLine("\"#\": \"set 0 for maximize intensity, set 1 for maximize structureness\",");
sw3->WriteLine("\"i_feature_maximize\": 1");
sw3->WriteLine("}");
sw3->WriteLine("}");
sw3->Close();